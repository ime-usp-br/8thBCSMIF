## Lições Aprendidas / Registro de Desenvolvimento - `criar_issues_script.sh`

**Versão:** 0.1.0<br>
**Data:** 2025-05-29

**Projeto:** `criar_issues_script.sh` (Automação de Criação/Edição de Issues GitHub)<br>
**Data:** 12 de Abril de 2025 (última atualização)<br>
**Versão Final do Script (nesta conversa):** v17

**Objetivo Inicial:** Criar um script Bash para automatizar a criação de issues no GitHub a partir de um arquivo de texto estruturado, utilizando templates Markdown e associando metadados como labels, assignee, projeto e milestone.

**Processo:** O script foi desenvolvido iterativamente, enfrentando e resolvendo diversos desafios relacionados à interação com a CLI `gh`, parsing de texto, escaping de caracteres e compatibilidade de ferramentas.

**Desafios Relevantes e Soluções Aplicadas:**

| Versão | Desafio / Sintoma / Erro                                                                 | Investigação / Diagnóstico                                                                                                                                 | Solução Aplicada (no Script)                                                                                                                                                                                             |
| :----- | :--------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| v8->v9 | `ACCEPTANCE_CRITERIA` (e outros multi-linhas) apareciam em uma única linha na issue final. | O `\n` literal no arquivo de plano não era interpretado como quebra de linha pelo `gh issue create -b "$body"`. O corpo era passado como um único argumento. | Alterar a execução para `printf '%s' "$issue_body" \| gh issue create -F - ...`. Isso passa o corpo via stdin, que o `gh` interpreta corretamente, preservando as quebras de linha. Simplificar a função `escape_for_sed_replacement`. |
| v9->v10 | Erro `sed: ... unterminated \`s' command` ao processar o corpo da issue.                   | Um caractere especial (provavelmente `/` ou `&` ou `\` ou `|`) dentro do *valor* multi-linhas estava quebrando o comando `sed "s|placeholder|value|g"`.      | Refinar a função `escape_for_sed_replacement` para escapar `\`, `&` e o delimitador `|` de forma robusta antes da substituição no `sed`.                                                                                    |
| v10->v11 | Projeto especificado no arquivo (`PROJECT: nome # comentario`) não era encontrado.      | O script estava incluindo o comentário `# comentario` como parte do nome do projeto ao fazer a busca com `gh project list`.                               | Ajustar a lógica de parsing do `KEY: VALUE` para remover comentários iniciados por `#` do valor *antes* de armazená-lo na array `issue_data`.                                                                         |
| v11->v12 | Script criava issues duplicadas se rodado novamente após uma falha parcial.             | O script não verificava se uma issue com o mesmo título já existia antes de tentar criar.                                                                    | Implementar `gh issue list` para buscar issues abertas com o título exato. Se encontrada, usar `gh issue edit <num>` para atualizar; senão, usar `gh issue create`.                                                      |
| v12->v13 | Erro `must provide --title and --body when not running interactively` no `gh issue create`. | Ao usar `-F -` para o corpo via stdin, o `gh issue create` também espera o título via stdin *a menos que* `-t` seja fornecido explicitamente na linha de comando. | Separar a construção dos flags. Para `gh issue create`, garantir que a flag `-t "$TITLE"` seja incluída junto com os outros metadados (`-l`, `-a`, `-m`, `-p`) ao chamar o comando com `-F -`.                                |
| v13->v14 | Erro `Warning: Failed check for existing issues (Code: 1)` ao usar `gh issue list --search`. | O comando `gh issue list --search "$TITLE"` falhava ou retornava resultados inesperados, provavelmente devido a caracteres especiais (`[]`) no título, quebrando o filtro `jq` subsequente. | Modificar a busca: usar `gh issue list --state open --limit XXX` (sem `--search`) para obter uma lista maior de issues abertas e fazer o filtro exato de título *e* estado *apenas* com `jq`. Mais robusto, porém potencialmente mais lento em repositórios com muitas issues. |
| v14->v15 | Erro `unknown shorthand flag: 'l' in -l` no `gh issue edit`.                          | O comando `gh issue edit` não usa `-l` para definir/adicionar labels, mas sim `--add-label` e `--remove-label`.                                             | Modificar o bloco "EDIT": em vez de passar `-l`, iterar sobre as labels desejadas e adicionar um flag `--add-label "$label"` para cada uma. (Decisão: não implementar `--remove-label` para simplificar).              |
| v15->v16 | Erro `unknown shorthand flag: 'a' in -a` no `gh issue edit`.                          | Similar ao problema dos labels, `gh issue edit` usa `--add-assignee login` (e `--remove-assignee`) em vez de `-a login`.                                     | Modificar o bloco "EDIT": substituir `-a "$assignee"` por `--add-assignee "$assignee"`. (Decisão: não implementar `--remove-assignee`).                                                                                 |
| v16->v17 | Erro `could not add to milestone '2': '2' not found` no `gh issue create` (logo após achar o milestone). | O `gh issue create` pode ter problemas de consistência da API ao tentar usar um ID numérico (`-m 2`) logo após a criação/verificação, ou prefere o título. | Modificar o script para usar o *título* do milestone (`-m "$global_milestone_title_to_use"`) em vez do número, tanto para `gh issue create` quanto para `gh issue edit`.                                                  |
| -      | Erro `GraphQL: Your token has not been granted the required scopes... 'addProjectV2ItemById' field requires... ['project']` | O token PAT usado pelo `gh` não tinha a permissão `project` (ou `project:write`) necessária para adicionar a issue ao projeto via API. Tinha apenas `read:project`. | **Solução Externa:** O usuário precisou editar as permissões do token PAT no site do GitHub ([github.com/settings/tokens](https://github.com/settings/tokens)) para adicionar o scope `project`. Nenhuma mudança no script foi necessária para este erro específico. |
| -      | Erro `jq: function not defined: arg/0` no lookup de milestone/label.                      | A versão do `jq` instalada no sistema não suportava a sintaxe `--arg variable value` para passar variáveis do shell para o `jq`.                               | **Solução:** Modificar as chamadas `jq` para embutir a variável do shell (devidamente escapada com `escape_for_jq_string`) diretamente na string do filtro `jq`, em vez de usar `--arg`.                                  |
| -      | Erro `invalid indirect expansion` ao passar `repo_flag_array[@]` para a função.           | A forma de passar a array (`[@]`) e tentar acessá-la via `${!var}` (indirect expansion) não é a ideal ou compatível em todos os cenários.                  | **Solução:** Utilizar *namerefs* (`declare -n ref=$varname`) (requer Bash 4.3+). Passar o *nome* da array para a função e acessá-la através da nameref dentro da função.                                                     |
| -      | Erro `Project '...' not found.` quando o projeto era da organização e não do usuário `@me`. | O script inicialmente só procurava projetos sob `@me`.                                                                                                  | **Solução:** Implementar busca em duas etapas: primeiro sob `@me`, depois sob o `repo_owner` (determinado via `gh repo view` ou `REPO_TARGET`). Falhar se não encontrar em nenhum dos dois.                               |

**Lições Gerais Aprendidas:**

*   **Flags da CLI `gh`:** `gh issue create` e `gh issue edit` possuem flags *diferentes* para operações semelhantes (e.g., `-l` vs `--add-label`, `-a` vs `--add-assignee`). É crucial consultar a ajuda (`--help`) de cada subcomando específico.
*   **Passagem de Corpo Multi-linha:** Usar `printf '%s' "$var" | gh command -F -` é a forma mais robusta de passar conteúdo multi-linha (como o corpo da issue) para comandos `gh` que suportam leitura de stdin.
*   **Escaping em Shell Scripts:** Escapar corretamente caracteres especiais para comandos como `sed` e `jq`, especialmente ao lidar com substituições e filtros que incluem variáveis do shell, é fundamental e pode exigir testes específicos. Usar delimitadores alternativos no `sed` (`s|...|...|g`) ajuda a evitar conflitos com `/`.
*   **Consistência da API do GitHub:** Pode haver pequenos delays de consistência na API (e.g., um milestone recém-criado não ser imediatamente encontrável pelo número). Usar identificadores mais estáveis (como títulos, quando permitido pela CLI) pode ser mais robusto do que depender de IDs numéricos em sequências rápidas de comandos.
*   **Verificação de Ferramentas/Versões:** Scripts complexos que dependem de múltiplas ferramentas (gh, jq, sed, awk, bash features) devem incluir verificações de dependência e, idealmente, de versão (como a verificação do Bash 4.3+ para `namerefs`).
*   **Debug Detalhado:** Usar `echo` para mostrar os comandos exatos que serão executados e capturar/exibir `stdout` e `stderr` de comandos externos é essencial para diagnosticar falhas.
*   **Permissões de Token:** Erros de API (GraphQL, HTTP 403) frequentemente indicam problemas de permissão (scopes) no token PAT, e não necessariamente um erro no script. `gh auth status` ajuda a ver os scopes atuais.

Este registro documenta a evolução do script e as soluções para os problemas encontrados, servindo como um guia útil para futuras manutenções ou para entender as decisões tomadas.